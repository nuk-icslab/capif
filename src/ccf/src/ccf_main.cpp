/**
 * Merged 3GPP CAPIF API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: h20
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "pistache/endpoint.h"
#include "pistache/http.h"
#include "pistache/router.h"
#include <spdlog/spdlog.h>
#include <yaml-cpp/yaml.h>

#include <mongocxx/client.hpp>
#include <mongocxx/instance.hpp>
#ifdef __linux__
#include <vector>
#include <signal.h>
#include <unistd.h>
#endif

#include "DefaultApiImpl.h"

#define PISTACHE_SERVER_THREADS 2
#define PISTACHE_SERVER_MAX_REQUEST_SIZE 32768
#define PISTACHE_SERVER_MAX_RESPONSE_SIZE 32768

static Pistache::Http::Endpoint *httpEndpoint;
#ifdef __linux__
static void sigHandler [[noreturn]] (int sig)
{
    switch (sig)
    {
    case SIGINT:
    case SIGQUIT:
    case SIGTERM:
    case SIGHUP:
    default:
        httpEndpoint->shutdown();
        break;
    }
    exit(0);
}

static void setUpUnixSignals(std::vector<int> quitSignals)
{
    sigset_t blocking_mask;
    sigemptyset(&blocking_mask);
    for (auto sig : quitSignals)
        sigaddset(&blocking_mask, sig);

    struct sigaction sa;
    sa.sa_handler = sigHandler;
    sa.sa_mask = blocking_mask;
    sa.sa_flags = 0;

    for (auto sig : quitSignals)
        sigaction(sig, &sa, nullptr);
}
#endif

using namespace org::openapitools::server::api;

int main()
{
#ifdef __linux__
    std::vector<int> sigs{SIGQUIT, SIGINT, SIGTERM, SIGHUP};
    setUpUnixSignals(sigs);
#endif
    YAML::Node ccf_config = YAML::LoadFile("config/ccf.yaml");
    int port = ccf_config["port"].as<int>();
    std::string mongo_url = ccf_config["mongo"]["url"].as<std::string>();
    std::string mongo_database =
        ccf_config["mongo"]["database"].as<std::string>();

    spdlog::info("CAPIF Core Function. version: {}", __CCF_VERSION__);

    /**
     * Initialize connection to MongoDB
     */
    mongocxx::instance inst{}; // This should be done only once.
    mongocxx::client db_conn{mongocxx::uri{mongo_url}};
    std::shared_ptr<mongocxx::database> db =
        std::make_shared<mongocxx::database>(db_conn[mongo_database]);

    Pistache::Address addr(Pistache::Ipv4::any(), Pistache::Port(port));

    httpEndpoint = new Pistache::Http::Endpoint((addr));
    auto router = std::make_shared<Pistache::Rest::Router>();

    auto opts = Pistache::Http::Endpoint::options()
                    .threads(PISTACHE_SERVER_THREADS);
    opts.flags(Pistache::Tcp::Options::ReuseAddr);
    opts.maxRequestSize(PISTACHE_SERVER_MAX_REQUEST_SIZE);
    opts.maxResponseSize(PISTACHE_SERVER_MAX_RESPONSE_SIZE);
    httpEndpoint->init(opts);
#ifdef USE_SSL
    httpEndpoint->useSSL("./certs/server.crt", "./certs/server.key");
#endif

    DefaultApiImpl DefaultApiserver(router, db);
    DefaultApiserver.init();

    spdlog::info("CAPIF core function is listening on port {}", port);
    httpEndpoint->setHandler(router->handler());
    httpEndpoint->serve();

    httpEndpoint->shutdown();
}
