/**
* CAPIF_Publish_Service_API
* API for publishing service APIs. Â© 2021, 3GPP Organizational Partners (ARIB, ATIS, CCSA, ETSI, TSDSI, TTA, TTC). All rights reserved. 
*
* The version of the OpenAPI document: 1.2.0-alpha.2
* 
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/


#include "AefProfile.h"
#include "Helpers.h"

#include <sstream>

namespace org::openapitools::server::model
{

AefProfile::AefProfile()
{
    m_AefId = "";
    m_ProtocolIsSet = false;
    m_DataFormatIsSet = false;
    m_SecurityMethodsIsSet = false;
    m_DomainName = "";
    m_DomainNameIsSet = false;
    m_InterfaceDescriptionsIsSet = false;
    
}

void AefProfile::validate() const
{
    std::stringstream msg;
    if (!validate(msg))
    {
        throw org::openapitools::server::helpers::ValidationException(msg.str());
    }
}

bool AefProfile::validate(std::stringstream& msg) const
{
    return validate(msg, "");
}

bool AefProfile::validate(std::stringstream& msg, const std::string& pathPrefix) const
{
    bool success = true;
    const std::string _pathPrefix = pathPrefix.empty() ? "AefProfile" : pathPrefix;

             
    
    /* Versions */ {
        const std::vector<Version>& value = m_Versions;
        const std::string currentValuePath = _pathPrefix + ".versions";
                
        
        if (value.size() < 1)
        {
            success = false;
            msg << currentValuePath << ": must have at least 1 elements;";
        }
        { // Recursive validation of array elements
            const std::string oldValuePath = currentValuePath;
            int i = 0;
            for (const Version& value : value)
            { 
                const std::string currentValuePath = oldValuePath + "[" + std::to_string(i) + "]";
                        
        success = value.validate(msg, currentValuePath + ".versions") && success;
 
                i++;
            }
        }

    }
                 
    if (securityMethodsIsSet())
    {
        const std::vector<SecurityMethod>& value = m_SecurityMethods;
        const std::string currentValuePath = _pathPrefix + ".securityMethods";
                
        
        if (value.size() < 1)
        {
            success = false;
            msg << currentValuePath << ": must have at least 1 elements;";
        }
        { // Recursive validation of array elements
            const std::string oldValuePath = currentValuePath;
            int i = 0;
            for (const SecurityMethod& value : value)
            { 
                const std::string currentValuePath = oldValuePath + "[" + std::to_string(i) + "]";
                        
        success = value.validate(msg, currentValuePath + ".securityMethods") && success;
 
                i++;
            }
        }

    }
             
    if (interfaceDescriptionsIsSet())
    {
        const std::vector<InterfaceDescription>& value = m_InterfaceDescriptions;
        const std::string currentValuePath = _pathPrefix + ".interfaceDescriptions";
                
        
        if (value.size() < 1)
        {
            success = false;
            msg << currentValuePath << ": must have at least 1 elements;";
        }
        { // Recursive validation of array elements
            const std::string oldValuePath = currentValuePath;
            int i = 0;
            for (const InterfaceDescription& value : value)
            { 
                const std::string currentValuePath = oldValuePath + "[" + std::to_string(i) + "]";
                        
        success = value.validate(msg, currentValuePath + ".interfaceDescriptions") && success;
 
                i++;
            }
        }

    }
    
    return success;
}

bool AefProfile::operator==(const AefProfile& rhs) const
{
    return
    
    
    (getAefId() == rhs.getAefId())
     &&
    
    (getVersions() == rhs.getVersions())
     &&
    
    
    ((!protocolIsSet() && !rhs.protocolIsSet()) || (protocolIsSet() && rhs.protocolIsSet() && getProtocol() == rhs.getProtocol())) &&
    
    
    ((!dataFormatIsSet() && !rhs.dataFormatIsSet()) || (dataFormatIsSet() && rhs.dataFormatIsSet() && getDataFormat() == rhs.getDataFormat())) &&
    
    
    ((!securityMethodsIsSet() && !rhs.securityMethodsIsSet()) || (securityMethodsIsSet() && rhs.securityMethodsIsSet() && getSecurityMethods() == rhs.getSecurityMethods())) &&
    
    
    ((!domainNameIsSet() && !rhs.domainNameIsSet()) || (domainNameIsSet() && rhs.domainNameIsSet() && getDomainName() == rhs.getDomainName())) &&
    
    
    ((!interfaceDescriptionsIsSet() && !rhs.interfaceDescriptionsIsSet()) || (interfaceDescriptionsIsSet() && rhs.interfaceDescriptionsIsSet() && getInterfaceDescriptions() == rhs.getInterfaceDescriptions()))
    
    ;
}

bool AefProfile::operator!=(const AefProfile& rhs) const
{
    return !(*this == rhs);
}

void to_json(nlohmann::json& j, const AefProfile& o)
{
    j = nlohmann::json();
    j["aefId"] = o.m_AefId;
    j["versions"] = o.m_Versions;
    if(o.protocolIsSet())
        j["protocol"] = o.m_Protocol;
    if(o.dataFormatIsSet())
        j["dataFormat"] = o.m_DataFormat;
    if(o.securityMethodsIsSet() || !o.m_SecurityMethods.empty())
        j["securityMethods"] = o.m_SecurityMethods;
    if(o.domainNameIsSet())
        j["domainName"] = o.m_DomainName;
    if(o.interfaceDescriptionsIsSet() || !o.m_InterfaceDescriptions.empty())
        j["interfaceDescriptions"] = o.m_InterfaceDescriptions;
    
}

void from_json(const nlohmann::json& j, AefProfile& o)
{
    j.at("aefId").get_to(o.m_AefId);
    j.at("versions").get_to(o.m_Versions);
    if(j.find("protocol") != j.end())
    {
        j.at("protocol").get_to(o.m_Protocol);
        o.m_ProtocolIsSet = true;
    } 
    if(j.find("dataFormat") != j.end())
    {
        j.at("dataFormat").get_to(o.m_DataFormat);
        o.m_DataFormatIsSet = true;
    } 
    if(j.find("securityMethods") != j.end())
    {
        j.at("securityMethods").get_to(o.m_SecurityMethods);
        o.m_SecurityMethodsIsSet = true;
    } 
    if(j.find("domainName") != j.end())
    {
        j.at("domainName").get_to(o.m_DomainName);
        o.m_DomainNameIsSet = true;
    } 
    if(j.find("interfaceDescriptions") != j.end())
    {
        j.at("interfaceDescriptions").get_to(o.m_InterfaceDescriptions);
        o.m_InterfaceDescriptionsIsSet = true;
    } 
    
}

std::string AefProfile::getAefId() const
{
    return m_AefId;
}
void AefProfile::setAefId(std::string const& value)
{
    m_AefId = value;
}
std::vector<Version> AefProfile::getVersions() const
{
    return m_Versions;
}
void AefProfile::setVersions(std::vector<Version> const& value)
{
    m_Versions = value;
}
Protocol AefProfile::getProtocol() const
{
    return m_Protocol;
}
void AefProfile::setProtocol(Protocol const& value)
{
    m_Protocol = value;
    m_ProtocolIsSet = true;
}
bool AefProfile::protocolIsSet() const
{
    return m_ProtocolIsSet;
}
void AefProfile::unsetProtocol()
{
    m_ProtocolIsSet = false;
}
DataFormat AefProfile::getDataFormat() const
{
    return m_DataFormat;
}
void AefProfile::setDataFormat(DataFormat const& value)
{
    m_DataFormat = value;
    m_DataFormatIsSet = true;
}
bool AefProfile::dataFormatIsSet() const
{
    return m_DataFormatIsSet;
}
void AefProfile::unsetDataFormat()
{
    m_DataFormatIsSet = false;
}
std::vector<SecurityMethod> AefProfile::getSecurityMethods() const
{
    return m_SecurityMethods;
}
void AefProfile::setSecurityMethods(std::vector<SecurityMethod> const& value)
{
    m_SecurityMethods = value;
    m_SecurityMethodsIsSet = true;
}
bool AefProfile::securityMethodsIsSet() const
{
    return m_SecurityMethodsIsSet;
}
void AefProfile::unsetSecurityMethods()
{
    m_SecurityMethodsIsSet = false;
}
std::string AefProfile::getDomainName() const
{
    return m_DomainName;
}
void AefProfile::setDomainName(std::string const& value)
{
    m_DomainName = value;
    m_DomainNameIsSet = true;
}
bool AefProfile::domainNameIsSet() const
{
    return m_DomainNameIsSet;
}
void AefProfile::unsetDomainName()
{
    m_DomainNameIsSet = false;
}
std::vector<InterfaceDescription> AefProfile::getInterfaceDescriptions() const
{
    return m_InterfaceDescriptions;
}
void AefProfile::setInterfaceDescriptions(std::vector<InterfaceDescription> const& value)
{
    m_InterfaceDescriptions = value;
    m_InterfaceDescriptionsIsSet = true;
}
bool AefProfile::interfaceDescriptionsIsSet() const
{
    return m_InterfaceDescriptionsIsSet;
}
void AefProfile::unsetInterfaceDescriptions()
{
    m_InterfaceDescriptionsIsSet = false;
}


} // namespace org::openapitools::server::model

